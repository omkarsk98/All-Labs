//	float a[][2] = {{80,300},{250,300},{150,340},{200,340},{150,340},{100,400},{200,340},{100,400},{80,380},{115,380},{132,380},{250,380},{250,340},{100,270},{150,300},{100,270},{200,300},{80,300},{40,194},{80,340},{40,340},{40,194},{250,338},{261,333},{320,333},{261,333},{261,310},{100,310},{100,330},{120,310},{120,330},{130,310},{130,330},{150,310},{150,330},{160,310},{160,330},{180,310},{180,330},{190,310},{190,330},{210,310},{210,330},{220,310},{220,330},{240,310},{240,330}};
#include <graphics.h>
// #include <conio.h>
// #include <dos.h>
#include <math.h>
#include <stdio.h>
void rotate(int, int, int, int);
int i = 0;
int x = 0;
float a[47][2];
float a[][2] = {{80, 300}, {250, 300}, {150, 340}, {200, 340}, {150, 340}, {100, 400}, {200, 340}, {100, 400}, {80, 380}, {115, 380}, {132, 380}, {250, 380}, {250, 340}, {100, 270}, {150, 300}, {100, 270}, {200, 300}, {80, 300}, {40, 194}, {80, 340}, {40, 340}, {40, 194}, {250, 338}, {261, 333}, {320, 333}, {261, 333}, {261, 310}, {100, 310}, {100, 330}, {120, 310}, {120, 330}, {130, 310}, {130, 330}, {150, 310}, {150, 330}, {160, 310}, {160, 330}, {180, 310}, {180, 330}, {190, 310}, {190, 330}, {210, 310}, {210, 330}, {220, 310}, {220, 330}, {240, 310}, {240, 330}};
void rotate(int n, int xp, int yp, int angle)
{
  /* 
    n = no. of coordinates
    xp and yp as pivot points
    angle as angle of rotation
  */
  // a[][2] = {{80 + i, 300}, {250 + i, 300}, {150 + i, 340}, {200 + i, 340}, {150 + i, 340}, {100 + i, 400}, {200 + i, 340}, {100 + i, 400}, {80 + i, 380}, {115 + i, 380}, {132 + i, 380}, {250 + i, 380}, {250 + i, 340}, {100 + i, 270}, {150 + i, 300}, {100 + i, 270}, {200 + i, 300}, {80 + i, 300}, {40 + i, 194}, {80 + i, 340}, {40 + i, 340}, {40 + i, 194}, {250 + i, 338}, {261 + i, 333}, {320 + i, 333}, {261 + i, 333}, {261 + i, 310}, {100 + i, 310}, {100 + i, 330}, {120 + i, 310}, {120 + i, 330}, {130 + i, 310}, {130 + i, 330}, {150 + i, 310}, {150 + i, 330}, {160 + i, 310}, {160 + i, 330}, {180 + i, 310}, {180 + i, 330}, {190 + i, 310}, {190 + i, 330}, {210 + i, 310}, {210 + i, 330}, {220 + i, 310}, {220 + i, 330}, {240 + i, 310}, {240 + i, 330}};

  while (x < n)
  {

    // int xs = xp - (xp * cos(angle) + yp * sin(angle));
    // int ys = yp + xp * sin(angle) - yp * cos(angle);
    // a[x][0] = a[x][0] * cos(angle) + a[x][1] * sin(angle) + xs;
    // a[x][1] = (a[x][0] * (-1) * sin(angle)) + a[x][1] * cos(angle) + ys;
    a[x][0] = a[x][0] - xp;
    a[x][1] = a[x][1] - yp;
    a[x][0] = a[x][0] * cos(angle) - a[x][1] * sin(angle);
    a[x][1] = a[x][0] * sin(angle) + a[x][1] * cos(angle);
    a[x][0] += xp;
    a[x][1] += yp;
    // printf("(%f %f) \t", a[x][0], a[x][1]);
    // printf("(%d,%d)\t", xs, ys);
    // delay(1000);
    // a[x][0] = xp + (xs * cos(angle) - ys * sin(angle));
    // a[x][1] = yp + (xs * sin(angle) + ys * cos(angle));
    // // printf("(%f %f) \n", a[x][0], a[x][1]);
    x++;
  }
}
void main()
{
  int j;
  int gd = DETECT, gm;
  initgraph(&gd, &gm, "C://TURBOC3//BGI");

  for (i = 0; i < 70; i++)
  {
    //Aircraft structure
    line(a[0][0] + i, a[0][1], a[1][0] + i, a[1][1]);
    line(a[2][0] + i, a[2][1], a[3][0] + i, a[3][1]);
    line(a[4][0] + i, a[4][1], a[5][0] + i, a[5][1]);
    line(a[6][0] + i, a[6][1], a[7][0] + i, a[7][1]);
    line(a[8][0] + i, a[8][1], a[9][0] + i, a[9][1]);
    line(a[10][0] + i, a[10][1], a[11][0] + i, a[11][1]);
    ellipse(a[12][0] + i, a[12][1], 270, 90, 80, 40);
    line(a[13][0] + i, a[13][1], a[14][0] + i, a[14][1]);
    line(a[15][0] + i, a[15][1], a[16][0] + i, a[16][1]);
    line(a[17][0] + i, a[17][1], a[18][0] + i, a[18][1]);
    arc(a[19][0] + i, a[19][1], 90, 180, 40);
    line(a[20][0] + i, a[20][1], a[21][0] + i, a[21][1]);
    ellipse(a[22][0] + i, a[22][1], 278, 350, 70, 30);
    line(a[23][0] + i, a[23][1], a[24][0] + i, a[24][1]);
    line(a[25][0] + i, a[25][1], a[26][0] + i, a[26][1]);
    //windows
    rectangle(a[27][0] + i, a[27][1], a[30][0] + i, a[30][1]);
    rectangle(a[31][0] + i, a[31][1], a[34][0] + i, a[34][1]);
    rectangle(a[35][0] + i, a[35][1], a[38][0] + i, a[38][1]);
    rectangle(a[39][0] + i, a[39][1], a[42][0] + i, a[42][1]);
    rectangle(a[43][0] + i, a[43][1], a[46][0] + i, a[46][1]);

    delay(10);
    cleardevice();
  }
  // printf("Initially: %f %f\n", a[0][0], a[0][1]);
  // rotate(47, 0 + i, 420, (-45));

  for (j = 0; j < 100; j++)
  {
    // printf("%f, %f\n", a[j][0], a[j][1]);
    // delay(500);
    // line(a[0][0], a[0][1], a[1][0], a[1][1]);
    line(a[0][0] + i + j, a[0][1] - j, a[1][0] + i + j, a[1][1] - j);
    line(a[2][0] + i + j, a[2][1] - j, a[3][0] + i + j, a[3][1] - j);
    line(a[4][0] + i + j, a[4][1] - j, a[5][0] + i + j, a[5][1] - j);
    line(a[6][0] + i + j, a[6][1] - j, a[7][0] + i + j, a[7][1] - j);
    line(a[8][0] + i + j, a[8][1] - j, a[9][0] + i + j, a[9][1] - j);
    line(a[10][0] + i + j, a[10][1] - j, a[11][0] + i + j, a[11][1] - j);
    ellipse(a[12][0] + i + j, a[12][1] - j, 270, 90, 80, 40);
    line(a[13][0] + i + j, a[13][1] - j, a[14][0] + i + j, a[14][1] - j);
    line(a[15][0] + i + j, a[15][1] - j, a[16][0] + i + j, a[16][1] - j);
    line(a[17][0] + i + j, a[17][1] - j, a[18][0] + i + j, a[18][1] - j);
    arc(a[19][0] + i + j, a[19][1] - j, 90, 180, 40);
    line(a[20][0] + i + j, a[20][1] - j, a[21][0] + i + j, a[21][1] - j);
    ellipse(a[22][0] + i + j, a[22][1] - j, 278, 350, 70, 30);
    line(a[23][0] + i + j, a[23][1] - j, a[24][0] + i + j, a[24][1] - j);
    line(a[25][0] + i + j, a[25][1] - j, a[26][0] + i + j, a[26][1] - j);
    //windows
    rectangle(a[27][0] + i + j, a[27][1] - j, a[30][0] + i + j, a[30][1] - j);
    rectangle(a[31][0] + i + j, a[31][1] - j, a[34][0] + i + j, a[34][1] - j);
    rectangle(a[35][0] + i + j, a[35][1] - j, a[38][0] + i + j, a[38][1] - j);
    rectangle(a[39][0] + i + j, a[39][1] - j, a[42][0] + i + j, a[42][1] - j);
    rectangle(a[43][0] + i + j, a[43][1] - j, a[46][0] + i + j, a[46][1] - j);
    delay(10);
    cleardevice();
    /* line(a[0][0] + j, a[0][1] - j, a[1][0] + j, a[1][1] - j);
    line(a[2][0] + j, a[2][1] - j, a[3][0] + j, a[3][1] - j);
    line(a[4][0] + j, a[4][1] - j, a[5][0] + j, a[5][1] - j);
    line(a[6][0] + j, a[6][1] - j, a[7][0] + j, a[7][1] - j);
    line(a[8][0] + j, a[8][1] - j, a[9][0] + j, a[9][1] - j);
    line(a[10][0] + j, a[10][1] - j, a[11][0] + j, a[11][1] - j);
    ellipse(a[12][0] + j, a[12][1] - j, 270, 90, 80, 40);
    line(a[13][0] + j, a[13][1] - j, a[14][0] + j, a[14][1] - j);
    line(a[15][0] + j, a[15][1] - j, a[16][0] + j, a[16][1] - j);
    line(a[17][0] + j, a[17][1] - j, a[18][0] + j, a[18][1] - j);
    arc(a[19][0] + j, a[19][1] - j, 180, 270, 40);
    line(a[20][0] + j, a[20][1] - j, a[21][0] + j, a[21][1] - j);
    ellipse(a[22][0] + j, a[22][1] - j, 10, 81, 70, 30);
    line(a[23][0] + j, a[23][1] - j, a[24][0] + j, a[24][1] - j);
    line(a[25][0] + j, a[25][1] - j, a[26][0] + j, a[26][1] - j);
    //windows
    rectangle(a[27][0] + j, a[27][1] - j, a[30][0] + j, a[30][1] - j);
    rectangle(a[31][0] + j, a[31][1] - j, a[34][0] + j, a[34][1] - j);
    rectangle(a[35][0] + j, a[35][1] - j, a[38][0] + j, a[38][1] - j);
    rectangle(a[39][0] + j, a[39][1] - j, a[42][0] + j, a[42][1] - j);
    rectangle(a[43][0] + j, a[43][1] - j, a[46][0] + j, a[46][1] - j);
    delay(10);
    cleardevice(); */
  }
  getch();
  closegraph();
}